<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Payment - CryptoCommerce SDK</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container" style="max-width: 600px; margin: 2rem auto; padding: 2rem;">
        <div id="payment-page-content">
            <h2>Loading payment...</h2>
        </div>
    </div>
    
    <script src="https://cdn.jsdelivr.net/npm/qrcode@1.5.3/build/qrcode.min.js"></script>
    <!-- Buffer polyfill for Solana SDK - must load before Solana SDK -->
    <script>
        // Buffer polyfill that extends Uint8Array directly (required by Solana SDK)
        (function() {
            if (typeof window !== 'undefined' && typeof window.Buffer === 'undefined') {
                // Create Buffer class that extends Uint8Array
                class BufferPolyfill extends Uint8Array {
                    constructor(arg, encoding) {
                        if (typeof arg === 'number') {
                            super(arg);
                        } else if (typeof arg === 'string') {
                            if (encoding === 'hex') {
                                const bytes = new Uint8Array(arg.length / 2);
                                for (let i = 0; i < arg.length; i += 2) {
                                    bytes[i / 2] = parseInt(arg.substr(i, 2), 16);
                                }
                                super(bytes.length);
                                this.set(bytes);
                            } else {
                                const bytes = new Uint8Array(arg.length);
                                for (let i = 0; i < arg.length; i++) {
                                    bytes[i] = arg.charCodeAt(i);
                                }
                                super(bytes.length);
                                this.set(bytes);
                            }
                        } else if (arg instanceof ArrayBuffer || arg instanceof Uint8Array) {
                            super(arg);
                        } else if (Array.isArray(arg)) {
                            super(arg);
                        } else {
                            super(0);
                        }
                    }
                    
                    static from(arg, encoding) {
                        if (typeof arg === 'string') {
                            if (encoding === 'hex') {
                                const bytes = new Uint8Array(arg.length / 2);
                                for (let i = 0; i < arg.length; i += 2) {
                                    bytes[i / 2] = parseInt(arg.substr(i, 2), 16);
                                }
                                return new BufferPolyfill(bytes);
                            }
                            const bytes = new Uint8Array(arg.length);
                            for (let i = 0; i < arg.length; i++) {
                                bytes[i] = arg.charCodeAt(i);
                            }
                            return new BufferPolyfill(bytes);
                        } else if (arg instanceof Uint8Array || arg instanceof ArrayBuffer) {
                            return new BufferPolyfill(arg);
                        } else if (Array.isArray(arg)) {
                            return new BufferPolyfill(arg);
                        }
                        return new BufferPolyfill(arg);
                    }
                    
                    static isBuffer(obj) {
                        return obj instanceof BufferPolyfill || obj instanceof Uint8Array;
                    }
                    
                    static alloc(size, fill) {
                        const buf = new BufferPolyfill(size);
                        if (fill !== undefined) {
                            buf.fill(fill);
                        }
                        return buf;
                    }
                    
                    toString(encoding) {
                        if (encoding === 'hex') {
                            return Array.from(this)
                                .map(b => b.toString(16).padStart(2, '0'))
                                .join('');
                        }
                        return String.fromCharCode.apply(null, this);
                    }
                }
                
                window.Buffer = BufferPolyfill;
                if (typeof global !== 'undefined') {
                    global.Buffer = BufferPolyfill;
                }
                
                // Polyfill for require (minimal, just to prevent errors)
                if (typeof require === 'undefined') {
                    window.require = function(module) {
                        console.warn('require() called for:', module, '- not available in browser');
                        return {};
                    };
                    if (typeof global !== 'undefined') {
                        global.require = window.require;
                    }
                }
            }
        })();
    </script>
    <script>
        // Suppress browser extension errors (MetaMask, etc.) - must be before any scripts
        (function() {
            const originalDefineProperty = Object.defineProperty;
            Object.defineProperty = function(obj, prop, descriptor) {
                if (prop === 'ethereum' || prop === 'web3') {
                    try {
                        return originalDefineProperty.call(this, obj, prop, descriptor);
                    } catch (e) {
                        if (e.message && e.message.includes('Cannot redefine property')) {
                            console.warn('Suppressed browser extension injection:', prop);
                            return obj;
                        }
                        throw e;
                    }
                }
                return originalDefineProperty.call(this, obj, prop, descriptor);
            };
        })();
    </script>
    <script>
        // Load SolanaWeb3 with multiple fallbacks (latest version)
        (function() {
            const cdnUrls = [
                'https://unpkg.com/@solana/web3.js@1.95.8/lib/index.iife.min.js',
                'https://cdn.jsdelivr.net/npm/@solana/web3.js@1.95.8/lib/index.iife.min.js',
                'https://unpkg.com/@solana/web3.js@latest/lib/index.iife.min.js',
                'https://cdn.jsdelivr.net/npm/@solana/web3.js@latest/lib/index.iife.min.js'
            ];
            
            let currentIndex = 0;
            
            function tryLoadSolana() {
                // Check multiple possible global variable names
                if (typeof window.SolanaWeb3 !== 'undefined' || 
                    typeof window.solanaWeb3 !== 'undefined') {
                    // Normalize to window.SolanaWeb3
                    if (window.solanaWeb3 && !window.SolanaWeb3) {
                        window.SolanaWeb3 = window.solanaWeb3;
                    }
                    console.log('✅ SolanaWeb3 already loaded');
                    return;
                }
                
                if (currentIndex >= cdnUrls.length) {
                    console.error('❌ All SolanaWeb3 CDNs failed. Payment functionality will be limited.');
                    return;
                }
                
                const script = document.createElement('script');
                script.src = cdnUrls[currentIndex];
                script.async = false; // Load synchronously
                script.crossOrigin = 'anonymous';
                
                script.onload = function() {
                    // Wait a bit for the script to initialize
                    setTimeout(function() {
                        // Check multiple possible global variable names
                        if (typeof window.SolanaWeb3 !== 'undefined') {
                            console.log(`✅ SolanaWeb3 loaded from CDN ${currentIndex + 1}`);
                        } else if (typeof window.solanaWeb3 !== 'undefined') {
                            window.SolanaWeb3 = window.solanaWeb3;
                            console.log(`✅ SolanaWeb3 loaded from CDN ${currentIndex + 1} (as solanaWeb3)`);
                        } else {
                            // Check if it's available in a different format
                            const possibleNames = ['SolanaWeb3', 'solanaWeb3', 'web3', 'solana'];
                            let found = false;
                            for (const name of possibleNames) {
                                if (typeof window[name] !== 'undefined' && window[name].Connection) {
                                    window.SolanaWeb3 = window[name];
                                    console.log(`✅ SolanaWeb3 loaded from CDN ${currentIndex + 1} (as ${name})`);
                                    found = true;
                                    break;
                                }
                            }
                            if (!found) {
                                console.warn(`⚠️ Script loaded but SolanaWeb3 not found, trying next CDN...`);
                                currentIndex++;
                                tryLoadSolana();
                            }
                        }
                    }, 200);
                };
                
                script.onerror = function() {
                    console.warn(`⚠️ CDN ${currentIndex + 1} failed, trying next...`);
                    currentIndex++;
                    setTimeout(tryLoadSolana, 500);
                };
                
                document.head.appendChild(script);
            }
            
            // Start loading immediately
            tryLoadSolana();
        })();
        
        async function loadPaymentLink() {
            const pathParts = window.location.pathname.split('/').filter(p => p);
            let linkId = pathParts[pathParts.length - 1];
            
            // Handle /pay/link_xxx format
            if (pathParts.length >= 2 && pathParts[pathParts.length - 2] === 'pay') {
                linkId = pathParts[pathParts.length - 1];
            }
            
            if (!linkId || linkId === 'pay' || linkId === 'pay.html') {
                document.getElementById('payment-page-content').innerHTML = `
                    <div style="text-align: center; padding: 2rem;">
                        <h2 style="color: var(--accent-error);">Invalid Payment Link</h2>
                        <p>This payment link is invalid or has expired.</p>
                        <a href="/" class="btn-primary" style="margin-top: 1rem; display: inline-block;">Go Home</a>
                    </div>
                `;
                return;
            }
            
            try {
                console.log('Loading payment link:', linkId);
                let response = await fetch(`/api/payment-links/${linkId}`);
                let link = null;
                
                if (response.ok) {
                    const data = await response.json();
                    link = data.link;
                }
                
                // If link not found, try to extract payment ID from linkId or create from payment ID
                if (!link) {
                    console.warn('Payment link not found, attempting to load payment directly...');
                    
                    // Try to extract payment ID from linkId (format: link_<timestamp>_<random>)
                    // Or if linkId starts with 'pay_', it's actually a payment ID
                    let paymentId = null;
                    if (linkId.startsWith('pay_')) {
                        paymentId = linkId;
                    } else if (linkId.startsWith('link_')) {
                        // Try to find payment by matching timestamp or create a link on-the-fly
                        // For now, we'll try to load payment directly if we can extract info
                    }
                    
                    // If we have a payment ID, try to load the payment and create a link on-the-fly
                    if (!paymentId) {
                        // Try to find payment by checking if linkId contains payment info
                        // Or try common payment IDs
                        const possiblePaymentId = linkId.replace('link_', 'pay_');
                        try {
                            const paymentResponse = await fetch(`/api/oracle/payments/${possiblePaymentId}`);
                            if (paymentResponse.ok) {
                                const paymentData = await paymentResponse.json();
                                if (paymentData.payment) {
                                    paymentId = possiblePaymentId;
                                }
                            }
                        } catch (e) {
                            // Ignore
                        }
                    }
                    
                    // If we found a payment, create a link on-the-fly
                    if (paymentId) {
                        try {
                            const paymentResponse = await fetch(`/api/oracle/payments/${paymentId}`);
                            if (paymentResponse.ok) {
                                const paymentData = await paymentResponse.json();
                                const payment = paymentData.payment;
                                
                                if (payment) {
                                    // Create a temporary link object
                                    link = {
                                        id: linkId,
                                        paymentId: payment.id,
                                        url: `${window.location.origin}/pay/${linkId}`,
                                        qrCode: {
                                            url: `solana:${payment.merchantAddress}?amount=${payment.solAmount}&reference=${payment.id}`,
                                            data: `solana:${payment.merchantAddress}?amount=${payment.solAmount}&reference=${payment.id}`
                                        },
                                        status: 'active',
                                        createdAt: payment.createdAt
                                    };
                                    
                                    displayPaymentPage(link, payment);
                                    return;
                                }
                            }
                        } catch (err) {
                            console.warn('Could not load payment:', err);
                        }
                    }
                    
                    // If still no link, show error
                    throw new Error('Payment link not found');
                }
                
                // Get payment details
                let payment = null;
                if (link.paymentId) {
                    try {
                        const paymentResponse = await fetch(`/api/oracle/payments/${link.paymentId}`);
                        if (paymentResponse.ok) {
                            const paymentData = await paymentResponse.json();
                            payment = paymentData.payment;
                        }
                    } catch (err) {
                        console.warn('Could not fetch payment details:', err);
                    }
                }
                
                displayPaymentPage(link, payment);
            } catch (error) {
                console.error('Failed to load payment link:', error);
                document.getElementById('payment-page-content').innerHTML = `
                    <div style="text-align: center; padding: 2rem;">
                        <h2 style="color: var(--accent-error);">Payment Link Not Found</h2>
                        <p>${error.message || 'This payment link may have expired or is invalid.'}</p>
                        <a href="/" class="btn-primary" style="margin-top: 1rem; display: inline-block;">Go Home</a>
                    </div>
                `;
            }
        }
        
        function displayPaymentPage(link, payment) {
            const content = document.getElementById('payment-page-content');
            
            if (!payment) {
                content.innerHTML = `
                    <div style="text-align: center; padding: 2rem;">
                        <h2 style="color: var(--accent-error);">Payment Not Found</h2>
                        <p>The payment associated with this link could not be found.</p>
                    </div>
                `;
                return;
            }
            
            const solAmount = payment.solAmount || payment.amount || 0;
            const token = payment.token || 'SOL';
            
            content.innerHTML = `
                <div style="background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 12px; padding: 2rem;">
                    <h2 style="margin-bottom: 1.5rem;">Payment Request</h2>
                    
                    <div style="margin-bottom: 1.5rem;">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 0.5rem;">
                            <span style="color: var(--text-secondary);">Amount:</span>
                            <span style="font-weight: 600;">$${payment.amount.toFixed(2)}</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-bottom: 0.5rem;">
                            <span style="color: var(--text-secondary);">Token Amount:</span>
                            <span style="font-weight: 600; color: var(--accent-primary);">${solAmount.toFixed(8)} ${token}</span>
                        </div>
                        ${payment.orderId ? `
                        <div style="display: flex; justify-content: space-between;">
                            <span style="color: var(--text-secondary);">Order ID:</span>
                            <span style="font-family: var(--font-mono); font-size: 0.9rem;">${payment.orderId}</span>
                        </div>
                        ` : ''}
                    </div>
                    
                    <div style="background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 8px; padding: 1.5rem; text-align: center; margin-bottom: 1.5rem;">
                        <h4 style="margin-bottom: 1rem;">QR Code</h4>
                        <div id="qr-code-container" style="display: flex; justify-content: center; margin-bottom: 1rem;"></div>
                        <p style="font-size: 0.85rem; color: var(--text-secondary); margin-top: 1rem;">
                            Scan with your Solana wallet to pay
                        </p>
                    </div>
                    
                    <div style="text-align: center;">
                        <button class="btn-primary" id="pay-with-wallet-btn" style="width: 100%; margin-bottom: 1rem;">
                            Pay with Wallet
                        </button>
                        <p style="font-size: 0.85rem; color: var(--text-secondary);">
                            Or scan the QR code above
                        </p>
                    </div>
                </div>
            `;
            
            // Generate QR code
            if (window.QRCode && link.qrCode) {
                const qrContainer = document.getElementById('qr-code-container');
                const qrText = link.qrCode.url || link.qrCode.data || link.url;
                if (qrText) {
                    window.QRCode.toCanvas(qrContainer, qrText, {
                        width: 256,
                        margin: 2,
                        color: {
                            dark: '#000000',
                            light: '#ffffff'
                        }
                    }, function (error) {
                        if (error) {
                            console.error('QR code generation error:', error);
                            // Fallback: create img element
                            qrContainer.innerHTML = `<img src="https://api.qrserver.com/v1/create-qr-code/?size=256x256&data=${encodeURIComponent(qrText)}" alt="QR Code" style="max-width: 100%; height: auto;">`;
                        }
                    });
                }
            } else if (link.qrCode) {
                // Fallback: use external QR code service
                const qrContainer = document.getElementById('qr-code-container');
                const qrText = link.qrCode.url || link.qrCode.data || link.url;
                qrContainer.innerHTML = `<img src="https://api.qrserver.com/v1/create-qr-code/?size=256x256&data=${encodeURIComponent(qrText)}" alt="QR Code" style="max-width: 100%; height: auto;">`;
            }
            
            // Pay with wallet button
            const payBtn = document.getElementById('pay-with-wallet-btn');
            if (payBtn) {
                payBtn.addEventListener('click', async () => {
                    // Wait for SolanaWeb3 to load with retry
                    if (typeof window.SolanaWeb3 === 'undefined') {
                        payBtn.disabled = true;
                        payBtn.textContent = 'Loading Solana library...';
                        
                        // Wait up to 5 seconds for SolanaWeb3
                        for (let i = 0; i < 50; i++) {
                            await new Promise(resolve => setTimeout(resolve, 100));
                            if (typeof window.SolanaWeb3 !== 'undefined') {
                                break;
                            }
                        }
                        
                        if (typeof window.SolanaWeb3 === 'undefined') {
                            alert('Solana library failed to load. Please refresh the page or scan the QR code to pay.');
                            payBtn.disabled = false;
                            payBtn.textContent = 'Pay with Wallet';
                            return;
                        }
                        
                        payBtn.disabled = false;
                        payBtn.textContent = 'Pay with Wallet';
                    }
                    
                    if (!window.solana || !window.solana.isPhantom) {
                        alert('Please install Phantom wallet to pay');
                        return;
                    }
                    
                    try {
                        payBtn.disabled = true;
                        payBtn.textContent = 'Connecting...';
                        
                        // Connect to wallet
                        const connectResponse = await window.solana.connect();
                        const publicKey = new window.SolanaWeb3.PublicKey(connectResponse.publicKey.toString());
                        
                        if (!payment || !payment.merchantAddress) {
                            alert('Payment error: Merchant address not found');
                            payBtn.disabled = false;
                            payBtn.textContent = 'Pay with Wallet';
                            return;
                        }
                        
                        const merchantPubkey = new window.SolanaWeb3.PublicKey(payment.merchantAddress);
                        
                        // Calculate lamports (handle different tokens)
                        let lamports = 0;
                        if (token === 'SOL') {
                            lamports = Math.floor(solAmount * 1e9);
                        } else {
                            // For SPL tokens, would need different handling
                            lamports = Math.floor(solAmount * 1e9); // Default to SOL for now
                        }
                        
                        payBtn.textContent = 'Preparing transaction...';
                        
                        // Create connection
                        // Use Alchemy RPC endpoint
                        const rpcUrl = 'https://solana-mainnet.g.alchemy.com/v2/xXPi6FAKVWJqv9Ie5TgvOHQgTlrlfbp5';
                        const connection = new window.SolanaWeb3.Connection(rpcUrl, 'confirmed');
                        
                        // Get fresh blockhash right before creating transaction (to avoid expiration)
                        payBtn.textContent = 'Getting latest blockhash...';
                        const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash('finalized');
                        
                        if (!blockhash) {
                            throw new Error('Failed to get blockhash from RPC');
                        }
                        
                        // Create transaction with fresh blockhash
                        // Use the constructor with all required fields
                        const transaction = new window.SolanaWeb3.Transaction({
                            feePayer: publicKey,
                            recentBlockhash: blockhash
                        });
                        
                        // Add transfer instruction
                        transaction.add(
                            window.SolanaWeb3.SystemProgram.transfer({
                                fromPubkey: publicKey,
                                toPubkey: merchantPubkey,
                                lamports: lamports
                            })
                        );
                        
                        // Verify blockhash is set (double-check)
                        if (!transaction.recentBlockhash) {
                            transaction.recentBlockhash = blockhash;
                        }
                        
                        // Verify feePayer is set
                        if (!transaction.feePayer) {
                            transaction.feePayer = publicKey;
                        }
                        
                        payBtn.textContent = 'Confirm in wallet...';
                        
                        // Sign and send transaction
                        // signAndSendTransaction returns { signature: '...' }
                        const result = await window.solana.signAndSendTransaction(transaction);
                        const signature = result.signature || result;
                        
                        // Wait for confirmation
                        await connection.confirmTransaction({
                            signature: signature,
                            blockhash: blockhash,
                            lastValidBlockHeight: lastValidBlockHeight
                        }, 'confirmed');
                        
                        payBtn.textContent = 'Notifying backend...';
                        
                        // Notify backend about the payment
                        try {
                            const verifyResponse = await fetch(`/api/oracle/payments/${payment.id}/verify`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ signature: signature })
                            });
                            
                            if (!verifyResponse.ok) {
                                console.warn('Backend verification failed:', await verifyResponse.text());
                            }
                        } catch (err) {
                            console.warn('Failed to notify backend:', err);
                        }
                        
                        alert(`Payment sent successfully! Transaction: ${signature}`);
                        window.location.href = '/';
                    } catch (error) {
                        console.error('Payment error:', error);
                        let errorMessage = 'Payment failed: ';
                        
                        if (error.message) {
                            errorMessage += error.message;
                        } else if (error.toString) {
                            errorMessage += error.toString();
                        } else {
                            errorMessage += 'Unknown error occurred';
                        }
                        
                        alert(errorMessage);
                        payBtn.disabled = false;
                        payBtn.textContent = 'Pay with Wallet';
                    }
                });
            }
        }
        
        // Wait for SolanaWeb3 to load before initializing
        function waitForSolanaWeb3(maxAttempts = 150) {
            if (typeof window.SolanaWeb3 !== 'undefined') {
                console.log('✅ SolanaWeb3 loaded successfully');
                loadPaymentLink();
            } else if (maxAttempts > 0) {
                setTimeout(() => waitForSolanaWeb3(maxAttempts - 1), 100);
            } else {
                // Fallback: try loading anyway (might work without SolanaWeb3 for display)
                console.warn('⚠️ SolanaWeb3 not loaded after 15 seconds, loading payment page anyway...');
                console.warn('⚠️ "Pay with Wallet" button will not work until SolanaWeb3 loads');
                console.warn('⚠️ You can still scan the QR code to pay');
                loadPaymentLink();
            }
        }
        
        // Start loading payment link immediately (don't wait for SolanaWeb3 for display)
        // SolanaWeb3 is only needed for "Pay with Wallet" button
        loadPaymentLink();
        
        // Also wait for SolanaWeb3 in background for button functionality
        setTimeout(() => waitForSolanaWeb3(), 500);
    </script>
</body>
</html>

